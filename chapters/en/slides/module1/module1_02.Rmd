---
params:
  dynamictitle: "module1_02"
title: "`r params$dynamictitle`"
output:
  md_document:
    variant: gfm
    pandoc_args: "--atx-headers"
---

```{r include=FALSE}
# Update the title in the YAML preamble for each slide show
knitr::opts_chunk$set(
    echo = TRUE,
    base.dir = ".",
    base.url = "/",
    fig.path = paste("../../../../static/module1/", params$dynamictitle,"/", sep = ""))

source('../../../../slide-setup.R')
```

type: slides

# How Can We Visualize Data?

Notes:
There is a plethora of visualization packages in Python.
This rich selection can be beneficial
but it is also confusing,
especially when starting out and trying to decide which package to choose.
When learning about data visualization,
it is helpful to distinguish between *imperative* and *declarative* plotting packages.

---

## Imperative (low level) plotting focuses on plot mechanics

- Focus on plot construction details.
    - Often includes loops, low-level drawing commands, etc.
- Specify *how* something should be done
    - "Draw a red point for every observation that has value X in column A,
      a blue point for every observation that has value Y in column A, etc."
- Minute control over plotting details, but laborious for complex visualization.

Notes:
*Imperative* plotting packages
focus on plot construction details
such as *how* to implement the visualization
in terms of for-loops, low-level drawing commands, etc.
This approach gives us minute control over what is plotted,
but it becomes quite laborious when we need to plot larger dataframes,
or create more complex visualizations.

---

## Example of imperative plotting

```python
# Pseudocode
colors = ['blue', 'red', 'yellow']
plot = create_plot()
for row_number, row_data in enumerate(dataframe):
    plot.add_point(x=row_data['Area'], y=row_data['Population'], color=colors[row_number])
```

```{python echo=F}
import pandas as pd
import altair as alt
from io import StringIO

data='''
Country|Area|Population
Russia|17098246|144386830
Canada|9984670|38008005
China|9596961|1400050000
'''

df = pd.read_table(StringIO(data), sep='|')

(alt.Chart(df).mark_circle(size=200).encode(
    alt.X('Area'),
    alt.Y('Population'),
    alt.Color('Country', legend=None, scale=alt.Scale(range=['steelblue', 'coral', '#FFDB58'])))
 .configure_axis(grid=False)
 .configure_view(stroke=None)
 .save('../../../../static/module1/pseudocode-plot.svg'))
```

<img src="/module1/pseudocode-plot.svg" alt="" width="65%"></img>

Notes:
In the example in this slide,
we will plot the area and the population
for the three largest countries in the world:

<table style="width:40%;">
<thead>
<tr class="header">
<th style="text-align: center;">Country</th>
<th style="text-align: center;">Area</th>
<th style="text-align: center;">Population</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Russia</td>
<td style="text-align: right;">17098246</td>
<td style="text-align: right;">144386830</td>
</tr>
<tr class="even">
<td>Canada</td>
<td style="text-align: right;">9984670</td>
<td style="text-align: right;">38008005</td>
</tr>
<tr class="odd">
<td>China</td>
<td style="text-align: right;">9596961</td>
<td style="text-align: right;">1400050000</td>
</tr>
</tbody>
</table>

We will use Python-inspired pseudocode,
which is code that is made up
and designed so that it is less complex and easier to read
than real programming languages.
This helps us focus on understanding the concepts of plotting
instead of getting hung up on the code syntax details of a particular package.

In this example,
you can see that an imperative approach to plotting this data
would be to first create the plot
and then loop through the dataframe
to add a point for each country one by one.
To color the points,
we need to manually create a sequence of colors
that we can access inside the loop.

The visualization on this page is an example of what a plot could look like
when run with real code similar to our pseudocode.

---

## Declarative (high level) plotting focuses on the data

- Focus on data and relationships.
    - Often includes data, graphical marks, and encoding channels.
- Specify *what* should be done
    - "Assign colors based on the values in column A"
- Smart defaults gives us what we want without complete control over minor plotting details.

Notes:
By *declarative*,
we mean that you can provide a high-level specification of *what* you want the visualization to include,
in terms of *data*, *graphical marks*, and *encoding channels*,

In summary,
declarative visualization tools lets you think about **data and relationship**,
while imperative visualization tools focus on **plot construction details**.

A key idea is that you declare links between data fields and visual encoding channels,
such as the x-axis, y-axis, color, *etc*.
The rest of the plot details are handled automatically.

---

## Example of declarative plotting

```python
# Pseudocode
point_plot(data=dataframe, x='Area', y='Population', color='Country')
```

```{python echo=F}
(alt.Chart(df).mark_circle(size=200).encode(
    alt.X('Area'),
    alt.Y('Population'),
    alt.Color('Country', scale=alt.Scale(range=['steelblue', 'coral', '#FFDB58'])))
 .configure_axis(grid=False)
 .configure_view(stroke=None)
 .save('../../../../static/module1/pseudocode-plot-with-legend.svg'))
```

<img src="/module1/pseudocode-plot-with-legend.svg" alt="" width="65%"></img>

Notes:
The visualization on this page is an example of what a plot could look like
when run with real code similar to our pseudocode.
You will notice that this time the plot also includes a legend
without us having to create it explicitly,
which is a common convenience in declarative plotting packages.

---

## A high level grammar of graphics helps us compose plots effectively

- Simple grammatical components combine to create visualizations.
- Visualization grammars often consist of three main components:
    1. Create a chart linked to a dataframe.
    2. Add graphical elements (such as points, lines, etc).
    3. Encode dataframe columns as visual channels (such as x, etc).

```python
# Pseudocode
chart(dataframe).add_points().encode_columns(x='Area', y='Population', color='Country')`.
```

Notes:
The declarative plotting concept can be implemented in different ways.
In the previous slide we had a dedicated function for creating the pointplot,
and there would be a separate function for creating a lineplot, barplot, etc.
With this approach,
it is often not easy to combine plots together,
unless there is a specific function for that purpose
and the three bullets points on this slide
are all executed by this single function.

Another way to use declarative plotting is via a visualization grammar.
Generally,
a grammar governs how individuals parts come together to compose
more complex constructs.
For example,
a linguistic grammar decides how words and phrases can be combined into coherent sentences.
A data visualization grammar
determines how to combine individual parts of the plotting syntax
to create complete visualization.
In this example on this slide,
you can see that the three bullet points are now broken down into one main
function to create the chart linked to the data,
and then we build upon this by adding the graphical elements (`add_points()`)
and the encoding of the columns to properties of this chart (`encode_columns()`).

By combining these three grammatical components in different ways,
we can build a wide range of visualizations,
without memorizing a unique function for each plot type.
Thanks to this grammatical visualization approach,
we also only require minimal changes to our code
to change the type of plot.

---

## The Python plotting landscape

<img src="/module1/py-plotting-landscape.png" alt="The Python plotting landscape" width="100%"></img>

Notes:
In this image you can see the most commonly used Python plotting packages.
There are many more,
but these are the ones you are the most likely to hear about,
so it is good to know that they exist.
As you can see there are several high and low level language,
so how to we chose?
In this course we have chosen to use Altair,
because it is a powerful high level visualization tool 
with a clear and consistent syntax
that also allows us to add interactive components to our plots,
such as tooltips and selections.

---

## A high level grammar of graphics helps us compose plots effectively

- Simple grammatical components combine to create visualizations.
- The Altair visualization grammar consist of three main components:
    1. Create a chart.
    2. Add a graphical mark.
    3. Encode dataframe columns as visual channels.
- In code, it looks like this: `Chart(data).mark().encode(x, y, ...)`.

```
Chart(dataframe).mark_point().encode(x='ColumnA', y='ColumnB', color='ColumnC')`.
```

Notes:
The declarative plotting concept can be implemented in different ways.
Here we will describe how a visualization grammar
can be used similarly to how grammar in regular language
is used to build complex linguistic constructs.
A wide range of simple to sophisticated visualizations can be created using a concise grammar.
Thanks to this functional way of interfacing with data,
only minimal changes are required if the underlying data change or to change the type of plot.

One of the most prominent declarative statistical visualization libraries is [Altair](https://altair-viz.github.io/).
Altair offer a powerful and concise visualization grammar for quickly building a wide range of statistical graphics.
In brief, you first create a chart,
then you indicate which graphical marks should represent the data (points, lines, etc)
and finally you encode your dataframe colums as different visual channels (x, y, color, etc).

Enough talking,
let's code!

---

## Sample data can be found in Altair's companion package vega_datasets

```{python}
from vega_datasets import data

cars = data.cars()
cars
```

Notes:
When specifying data in Altair,
it is important that dataframes are in the ["tidy"](http://vita.had.co.nz/papers/tidy-data.html) format.
They should consist of a set of named data *columns* (also called *fields* or *variables*)
with one feature each
and rows with one *observation* each.
In our Altair examples
we will often use data from the [vega-datasets](https://github.com/vega/vega-datasets) package.
Many of these datasets are directly available as Pandas dataframes,
such as the `cars` dataset.

---

## Let's create our first plot

```{python}
import altair as alt

alt.Chart(cars).mark_point()
```

Notes:
The fundamental object in Altair is the `Chart`,
which takes a data frame as a single argument `alt.Chart(cars)`.

With a chart object in hand,
we can now specify how we would like the data to be visualized.
We first indicate what kind of geometric *mark* we want to use to represent the data.
We can set the `mark` attribute of the chart object using the `Chart.mark_*` methods.

For example, we can show the data as a point using `mark_point()`,
as in this slide.
In this plot,
the rendering consists of one point per row in the dataset,
all plotted on top of each other,
since we have not yet specified positions for these points.

---

## Encoding channels

### Mapping a data feature to the x-scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon')
```

Notes:
To visually separate the points,
we can map various *encoding channels*,
or *channels* for short,
to columns in the dataset.
For example,
we could *encode* the column `Miles_per_Gallon` of the data using the `x` channel,
which represents the x-axis position of the points.
To specify this,
use the `encode` method as in the slide
to map a dataframe column to a visual channel, such as x, y, or color.
For Pandas data frames,
Altair automatically determines an appropriate data type for the mapped column,
which in this case is quantitative (or numerical).

---

## Mapping a data feature to the y-scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower')
```

Notes:
Though we've now separated the data by one attribute,
we still have multiple points overlapping within each category.
Let's further separate these by adding an `y` encoding channel:

---

## Mapping a numerical data feature to the color scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Weight_in_lbs')

```

Notes:
We can specify which column we want to color the points by
and Altair will automatically figure out an appropriate colorscale to use.

---

## Mapping a categorical data feature to the color scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Origin')
```

Notes:
Since we used a column with numerical (also called "quantitative") data,
a continuous, gradually increasing colorscale was used.
If we instead choose a color with categorical (also called "nominal") data,
Altair will automatically pick a suitable colorscale with distinct colors.

---

## Mapping a data feature to the shape scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Origin',
    shape='Origin')
```

Notes:
We can encode shapes aesthetics the same way.

---

## Mapping a data feature to the size scale


```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Origin',
    shape='Origin',
    size='Weight_in_lbs')
```

Notes:
Another common encoding aesthetic is `size`.
The plot is now quite messy,
there are too many things going on to be able to see the variation in weight.
If you go back to the plot where we encoded weight in the color channel,
you can see that the plot is much clearer.
There is plenty of research on which channels are best for what features,
which we will learn more about next lecture.

---

# Let's apply what we learned!

Notes: <br>
