---
params:
  dynamictitle: "module1_02"
title: "`r params$dynamictitle`"
output:
  md_document:
    variant: gfm
    pandoc_args: "--atx-headers"
---

```{r include=FALSE}
# Update the title in the YAML preamble for each slide show
knitr::opts_chunk$set(
    echo = TRUE,
    base.dir = ".",
    base.url = "/",
    fig.path = paste("../../../../static/module1/", params$dynamictitle,"/", sep = ""))

source('../../../../slide-setup.R')
```

type: slides

# How Can We Visualize Data?

Notes:
There is a plethora of visualization packages in Python.
This rich selection can be beneficial, but is also confusing,
especially when starting out trying to decide which one to choose.
A helpful distinction to make is between *low level* and *high level* plotting packages.

---

## Low level and high level visualization concepts

### Low level (imperative)

- Focus on plot construction details.
    - Often includes loops, low-level drawing commands, etc.
- Specify *how* something should be done
    - "Draw a red point for every observation that has value X in column A,
      a blue point for every observation that has value Y in column A, etc."

### High level (declarative)

- Focus on data and relationships.
    - Often includes data, graphical marks, and encoding channels.
- Specify *what* should be done
    - "Assign colors based on the values in column A"

Notes:
By *declarative*,
we mean that you can provide a high-level specification of *what* you want the visualization to include,
in terms of *data*, *graphical marks*, and *encoding channels*,
rather than having to specify *how* to implement the visualization in terms of for-loops, low-level drawing commands, *etc*.
For example,
you would say "color my data by the column 'country'"
instead of "go through this data frame and plot any observations of country1 in blue, any observations of country in red, etc".

Declarative visualization tools lets you think about **data and relationship**,
rather than **plot construction details**.
A key idea is that you declare links between data fields and visual encoding channels,
such as the x-axis, y-axis, color, *etc*.
The rest of the plot details are handled automatically.

---

## The Python plotting landscape

<img src="/module1/py-plotting-landscape.png" alt="The Python plotting landscape" width="100%"></img>

Notes:
In this image you can see the most commonly used Python plotting packages.
There are many more,
but these are the ones you are the most likely to hear about,
so it is good to know that they exist.
As you can see there are several high and low level language,
so how to we chose?
In this course we have chosen to use Altair,
because it is a powerful high level visualization tool 
with a clear and consistent syntax
that also allows us to add interactive components to our plots,
such as tooltips and selections.

---

## A high level grammar of graphics

- Simple grammatical components combine to create visualizations.
- The Altair visualization grammar consist of three main components:
    1. Create a chart.
    2. Add a graphical mark.
    3. Encode dataframe columns as visual channels.
- In code, it looks like this: `Chart(data).mark().encode(x, y, ...)`.

Notes:
The declarative plotting concept can be implemented in different ways.
Here we will describe how a visualization grammar
can be used similarly to how grammar in regular language
is used to build complex linguistic constructs.
A wide range of simple to sophisticated visualizations can be created using a concise grammar.
Thanks to this functional way of interfacing with data,
only minimal changes are required if the underlying data change or to change the type of plot.

One of the most prominent declarative statistical visualization libraries is [Altair](https://altair-viz.github.io/).
Altair offer a powerful and concise visualization grammar for quickly building a wide range of statistical graphics.
In brief, you first create a chart,
then you indicate which graphical marks should represent the data (points, lines, etc)
and finally you encode your dataframe colums as different visual channels (x, y, color, etc).

Enough talking,
let's code!

---

## Sample data

```{python}
from vega_datasets import data

cars = data.cars()
cars
```

Notes:
When specifying data in Altair,
it is important that dataframes are in the ["tidy"](http://vita.had.co.nz/papers/tidy-data.html) format.
They should consist of a set of named data *columns* (also called *fields* or *variables*)
with one feature each
and rows with one *observation* each.
In our Altair examples
we will often use data from the [vega-datasets](https://github.com/vega/vega-datasets) package.
Many of these datasets are directly available as Pandas dataframes,
such as the `cars` dataset.

---

## Our first plot

```{python}
import altair as alt

alt.Chart(cars).mark_point()
```

Notes:
The fundamental object in Altair is the `Chart`,
which takes a data frame as a single argument `alt.Chart(cars)`.

With a chart object in hand,
we can now specify how we would like the data to be visualized.
We first indicate what kind of geometric *mark* we want to use to represent the data.
We can set the `mark` attribute of the chart object using the `Chart.mark_*` methods.

For example, we can show the data as a point using `mark_point()`,
as in this slide.
In this plot,
the rendering consists of one point per row in the dataset,
all plotted on top of each other,
since we have not yet specified positions for these points.

---

## Encoding channels

### Mapping a data feature to the x-scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon')
```

Notes:
To visually separate the points,
we can map various *encoding channels*,
or *channels* for short,
to columns in the dataset.
For example,
we could *encode* the column `Miles_per_Gallon` of the data using the `x` channel,
which represents the x-axis position of the points.
To specify this,
use the `encode` method as in the slide
to map a dataframe column to a visual channel, such as x, y, or color.
For Pandas data frames,
Altair automatically determines an appropriate data type for the mapped column,
which in this case is quantitative (or numerical).

---

## Mapping a data feature to the y-scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower')
```

Notes:
Though we've now separated the data by one attribute,
we still have multiple points overlapping within each category.
Let's further separate these by adding an `y` encoding channel:

---

## Mapping a numerical data feature to the color scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Weight_in_lbs')

```

Notes:
We can specify which column we want to color the points by
and Altair will automatically figure out an appropriate colorscale to use.

---

## Mapping a categorical data feature to the color scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Origin')
```

Notes:
Since we used a column with numerical (also called "quantitative") data,
a continuous, gradually increasing colorscale was used.
If we instead choose a color with categorical (also called "nominal") data,
Altair will automatically pick a suitable colorscale with distinct colors.

---

## Mapping a data feature to the shape scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Origin',
    shape='Origin')
```

Notes:
We can encode shapes aesthetics the same way.

---

## Mapping a data feature to the size scale


```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Origin',
    shape='Origin',
    size='Weight_in_lbs')
```

Notes:
Another common encoding aesthetic is `size`.
The plot is now quite messy,
there are too many things going on to be able to see the variation in weight.
If you go back to the plot where we encoded weight in the color channel,
you can see that the plot is much clearer.
There is plenty of research on which channels are best for what features,
which we will learn more about next lecture.

---

## Trends over time with scatter plots

```{python}
alt.Chart(cars).mark_point().encode(
    x='Year',
    y='Miles_per_Gallon')
```

Notes:
We can use the point chart to visualize trends over time,
such as how the miles per gallon has changes over the years.

---

## Trends over time with line plots

```{python}
alt.Chart(cars).mark_line().encode(
    x='Year',
    y='Miles_per_Gallon')
```

Notes:
However,
trends are often more effectively visualized with lines,
since the slope can help visualize the difference overtime.
Let's try switching our mark to a line.

Oh oh, something is wrong.
Because there are multiple values per year,
the line goes between all of them vertically and it just looks really odd.

---

## Aggregate the data for each year

```{python}
yearly_avg_gallons = cars.groupby('Year')['Miles_per_Gallon'].mean().reset_index()

alt.Chart(yearly_avg_gallons).mark_line().encode(
    x='Year',
    y='Miles_per_Gallon')
```

Notes:
Instead,
what we want is to aggregate the data
(e.g. by calculating the mean or median per year),
so that there is only one point per year.
We could wrangle the data manually in pandas before plotting it
like in this slide.

---

## Data aggregation in Altair instead of in pandas

```{python}
alt.Chart(cars).mark_line().encode(
    x='Year',
    y='mean(Miles_per_Gallon)')
```

Notes:
Instead of doing this two step process with pandas,
we could aggregate right inside Altair!
To get the mean of a column,
wrap it in a string that says `'mean()'` as in this slide.

That is a convenient short cut!
Many common aggregations/transformations are available via this syntax,
[more info in the documentation including a table with all available aggregations](https://altair-viz.github.io/user_guide/encoding.html#binning-and-aggregation).

---

## Grouping before aggregating

```{python}
alt.Chart(cars).mark_line().encode(
    x='Year',
    y='mean(Miles_per_Gallon)',
    color='Origin')
```

Notes:
Altair understands that when we specify for example a color 
together with an aggregation,
we want to take the mean of each group
in the color channel separately.
This works just like if we had done the following in pandas
`groupby('Origin').mean('Miles_per_Gallong)`,
and gives us one line per group in this plot.

---

## Combining marks via Layering

```{python}
line = alt.Chart(cars).mark_line().encode(
    x='Year',
    y='mean(Miles_per_Gallon)')

point = alt.Chart(cars).mark_point().encode(
    x='Year',
    y='mean(Miles_per_Gallon)')

line + point
```

Notes:
As we've seen above, the Altair `Chart` object represents a plot with a single mark type.
What about more complicated diagrams, involving multiple charts or layers?
Using a set of *view composition* operators,
Altair can take multiple chart definitions
and combine them to create more complex views.

To augment this plot,
we might like to add `point` marks for each averaged data point.
We can start by defining each chart separately:
first a line plot,
then a scatter plot.
We can then use the `layer` operator to combine the two into a layered chart.
Here we use the shorthand `+` (plus) operator to invoke layering.

---

## Briefer syntax by building upon previous plots

```{python}
line = alt.Chart(cars).mark_line().encode(
    x='Year',
    y='mean(Miles_per_Gallon)')

line + line.mark_point()
```

Notes:
We can also create this chart by *reusing* and *modifying* a previous chart definition!
Rather than completely re-write a chart,
we can start with the line chart,
then invoke the `mark_point` method
to generate a new chart definition with a different mark type:
We could also have typed `mark_line(point=True)`,
which is a special case for getting points on a line
since it is such a common operation.

---

## Showing raw values together with the mean

```{python}
line = alt.Chart(cars).mark_line().encode(
    x='Year',
    y='mean(Miles_per_Gallon)')

line + line.mark_point().encode(y='Miles_per_Gallon')
```


Notes:
We can also create a layer with one point per observations,
and with a line for the average values.
For this we need to use `encode` again
after creating the first plot,
to instruct Altair to use the raw vales
instead of the mean for the points.
(Note that the axis now has two labels,
we will see how to change that next lecture.)

---

## Adding color to separate layers

```{python}
line = alt.Chart(cars).mark_line().encode(
    x='Year',
    y='mean(Miles_per_Gallon)',
    color='Origin')

line + line.mark_point().encode(y='Miles_per_Gallon')
```

Notes:
Adding color to the base chart propagates it to all the layers.
If we would only have added it to the point chart,
there would still have been a single line instead of three.

---

# Let's apply what we learned!

Notes: <br>
