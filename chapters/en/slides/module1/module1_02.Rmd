---
params:
  dynamictitle: "module1_02"
title: "`r params$dynamictitle`"
output:
  md_document:
    variant: gfm
    pandoc_args: "--atx-headers"
---

```{r include=FALSE}
# Update the title in the YAML preamble for each slide show
knitr::opts_chunk$set(
    echo = TRUE,
    base.dir = ".",
    base.url = "/",
    fig.path = paste("../../../../static/module1/", params$dynamictitle,"/", sep = ""))

source('../../../../slide-setup.R')
```

type: slides

# How Can We Visualize Data?

Notes:
There is a plethora of visualization packages in Python.
This rich selection can be beneficial, but is also confusing,
especially when starting out trying to decide which one to choose.
A helpful distinction to make is between *low level* and *high level* plotting packages.

---

## Low level and high level visualization concepts

### Low level (imperative)

- Focus on plot construction details.
    - Often includes loops, low-level drawing commands, etc.
- Specify *how* something should be done
    - "Draw a red point for every observation that has value X in column A,
      a blue point for every observation that has value Y in column A, etc."

### High level (declarative)

- Focus on data and relationships.
    - Often includes data, graphical marks, and encoding channels.
- Specify *what* should be done
    - "Assign colors based on the values in column A"

Notes:
By *declarative*,
we mean that you can provide a high-level specification of *what* you want the visualization to include,
in terms of *data*, *graphical marks*, and *encoding channels*,
rather than having to specify *how* to implement the visualization in terms of for-loops, low-level drawing commands, *etc*.
For example,
you would say "color my data by the column 'country'"
instead of "go through this data frame and plot any observations of country1 in blue, any observations of country in red, etc".

Declarative visualization tools lets you think about **data and relationship**,
rather than **plot construction details**.
A key idea is that you declare links between data fields and visual encoding channels,
such as the x-axis, y-axis, color, *etc*.
The rest of the plot details are handled automatically.

---

## The Python plotting landscape

<img src="/module1/py-plotting-landscape.png" alt="The Python plotting landscape" width="100%"></img>

Notes:
In this image you can see the most commonly used Python plotting packages.
There are many more,
but these are the ones you are the most likely to hear about,
so it is good to know that they exist.
As you can see there are several high and low level language,
so how to we chose?
In this course we have chosen to use Altair,
because it is a powerful high level visualization tool 
with a clear and consistent syntax
that also allows us to add interactive components to our plots,
such as tooltips and selections.

---

## A high level grammar of graphics

- Simple grammatical components combine to create visualizations.
- The Altair visualization grammar consist of three main components:
    1. Create a chart.
    2. Add a graphical mark.
    3. Encode dataframe columns as visual channels.
- In code, it looks like this: `Chart(data).mark().encode(x, y, ...)`.

Notes:
The declarative plotting concept can be implemented in different ways.
Here we will describe how a visualization grammar
can be used similarly to how grammar in regular language
is used to build complex linguistic constructs.
A wide range of simple to sophisticated visualizations can be created using a concise grammar.
Thanks to this functional way of interfacing with data,
only minimal changes are required if the underlying data change or to change the type of plot.

One of the most prominent declarative statistical visualization libraries is [Altair](https://altair-viz.github.io/).
Altair offer a powerful and concise visualization grammar for quickly building a wide range of statistical graphics.
In brief, you first create a chart,
then you indicate which graphical marks should represent the data (points, lines, etc)
and finally you encode your dataframe colums as different visual channels (x, y, color, etc).

Enough talking,
let's code!

---

## Sample data

```{python}
from vega_datasets import data

cars = data.cars()
cars
```

Notes:
When specifying data in Altair,
it is important that dataframes are in the ["tidy"](http://vita.had.co.nz/papers/tidy-data.html) format.
They should consist of a set of named data *columns* (also called *fields* or *variables*)
with one feature each
and rows with one *observation* each.
In our Altair examples
we will often use data from the [vega-datasets](https://github.com/vega/vega-datasets) package.
Many of these datasets are directly available as Pandas dataframes,
such as the `cars` dataset.

---

## Our first plot

```{python}
import altair as alt

alt.Chart(cars).mark_point()
```

Notes:
The fundamental object in Altair is the `Chart`,
which takes a data frame as a single argument `alt.Chart(cars)`.

With a chart object in hand,
we can now specify how we would like the data to be visualized.
We first indicate what kind of geometric *mark* we want to use to represent the data.
We can set the `mark` attribute of the chart object using the `Chart.mark_*` methods.

For example, we can show the data as a point using `mark_point()`,
as in this slide.
In this plot,
the rendering consists of one point per row in the dataset,
all plotted on top of each other,
since we have not yet specified positions for these points.

---

## Encoding channels

### Mapping a data feature to the x-scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon')
```

Notes:
To visually separate the points,
we can map various *encoding channels*,
or *channels* for short,
to columns in the dataset.
For example,
we could *encode* the column `Miles_per_Gallon` of the data using the `x` channel,
which represents the x-axis position of the points.
To specify this,
use the `encode` method as in the slide
to map a dataframe column to a visual channel, such as x, y, or color.
For Pandas data frames,
Altair automatically determines an appropriate data type for the mapped column,
which in this case is quantitative (or numerical).

---

## Mapping a data feature to the y-scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower')
```

Notes:
Though we've now separated the data by one attribute,
we still have multiple points overlapping within each category.
Let's further separate these by adding an `y` encoding channel:

---

## Mapping a numerical data feature to the color scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Weight_in_lbs')

```

Notes:
We can specify which column we want to color the points by
and Altair will automatically figure out an appropriate colorscale to use.

---

## Mapping a categorical data feature to the color scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Origin')
```

Notes:
Since we used a column with numerical (also called "quantitative") data,
a continuous, gradually increasing colorscale was used.
If we instead choose a color with categorical (also called "nominal") data,
Altair will automatically pick a suitable colorscale with distinct colors.

---

## Mapping a data feature to the shape scale

```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Origin',
    shape='Origin')
```

Notes:
We can encode shapes aesthetics the same way.

---

## Mapping a data feature to the size scale


```{python}
alt.Chart(cars).mark_point().encode(
    x='Miles_per_Gallon',
    y='Horsepower',
    color='Origin',
    shape='Origin',
    size='Weight_in_lbs')
```

Notes:
Another common encoding aesthetic is `size`.
The plot is now quite messy,
there are too many things going on to be able to see the variation in weight.
If you go back to the plot where we encoded weight in the color channel,
you can see that the plot is much clearer.
There is plenty of research on which channels are best for what features,
which we will learn more about next lecture.

---

# Let's apply what we learned!

Notes: <br>
